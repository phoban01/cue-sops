package main

import (
	"fmt"
	"os"
	"strings"
	"time"

	"go.mozilla.org/sops/v3"
	"go.mozilla.org/sops/v3/aes"
	"go.mozilla.org/sops/v3/cmd/sops/common"
	"go.mozilla.org/sops/v3/cmd/sops/formats"
	"go.mozilla.org/sops/v3/config"
	"go.mozilla.org/sops/v3/keyservice"
	"go.mozilla.org/sops/v3/version"

	"cuelang.org/go/cue"
	"cuelang.org/go/cue/ast"
	"cuelang.org/go/cue/ast/astutil"
	"cuelang.org/go/cue/cuecontext"
	"cuelang.org/go/cue/format"
	"cuelang.org/go/cue/parser"
	"cuelang.org/go/cue/token"
	"cuelang.org/go/encoding/json"
	cuejson "cuelang.org/go/pkg/encoding/json"
)

type Operation int

const (
	encrypt Operation = iota
	decrypt
)

var (
	inplace   bool   = true
	filename  string = "secrets.cue"
	operation Operation
)

func main() {
	switch os.Args[1] {
	case "encrypt":
		operation = encrypt
	case "decrypt":
		operation = decrypt
	default:
		panic("must provide encrypt or decrypt")
	}
	tree, err := parser.ParseFile(filename, nil)
	if err != nil {
		panic(err)
	}

	ctx := cuecontext.New()

	cueData := ctx.BuildFile(tree)

	sopsStruct := cueData.LookupPath(cue.ParsePath("sops"))
	if sopsStruct.Exists() && operation == encrypt {
		os.Exit(0)
	} else if !sopsStruct.Exists() && operation == decrypt {
		os.Exit(1)
	}

	fieldsToEncode := make([]string, 0)

	for _, v := range getFieldsToEncode(tree) {
		name := v.(*ast.Field).Label.(*ast.Ident).Name
		fieldsToEncode = append(fieldsToEncode, name)
	}

	regex := strings.Join(fieldsToEncode, "|")

	y := cueData.LookupPath(cue.ParsePath("constraint"))

	x := cueData.UnifyAccept(cueData, y)

	jsonData, err := cuejson.Marshal(x)
	if err != nil {
		panic(err)
	}

	encData, err := encryptData([]byte(jsonData), regex)
	if err != nil {
		panic(err)
	}

	encDataCue, err := json.Extract("encoded.cue", encData)
	if err != nil {
		panic(err)
	}

	ctx = cuecontext.New()

	v := ctx.BuildExpr(encDataCue)

	metadata := &ast.Field{
		Label: ast.NewIdent("sops"),
		Value: ast.Embed(v.LookupPath(cue.ParsePath("sops")).Syntax().(*ast.StructLit)).Expr,
	}

	result, err := insertEncodedValues(tree, v, operation)
	if err != nil {
		panic(err)
	}

	resultFile := result.(*ast.File)

	comment := ast.NewLit(token.COMMENT, "\n// DO NOT EDIT: auto-generated by tooling")

	decls := resultFile.Decls

	if decls[len(decls)-1].(*ast.Field).Label.(*ast.Ident).Name != "sops" {
		resultFile.Decls = append(resultFile.Decls, comment, metadata)
	} else {
		resultFile.Decls[len(decls)-1] = metadata
	}

	output, err := format.Node(result)
	if err != nil {
		panic(err)
	}

	if err := os.WriteFile(filename, output, os.ModePerm); err != nil {
		panic(err)
	}
}

// get back the result
// parse as cue
// set the node value to the encoded bit
// create a top-level sops key equal to the value of the metadata

func encryptData(data []byte, regex string) ([]byte, error) {
	sopsConf, err := config.LoadCreationRuleForFile(".sops.yaml", "secrets.cue", nil)
	if err != nil {
		return nil, err
	}

	store := common.StoreForFormat(formats.Json)

	branches, err := store.LoadPlainFile(data)
	if err != nil {
		return nil, err
	}

	tree := sops.Tree{
		Branches: branches,
		Metadata: sops.Metadata{
			UnencryptedSuffix: sopsConf.UnencryptedSuffix,
			EncryptedSuffix:   sopsConf.EncryptedSuffix,
			UnencryptedRegex:  sopsConf.UnencryptedRegex,
			EncryptedRegex:    regex,
			KeyGroups:         sopsConf.KeyGroups,
			ShamirThreshold:   sopsConf.ShamirThreshold,
			Version:           version.Version,
		},
	}

	svcs := []keyservice.KeyServiceClient{
		keyservice.NewLocalClient(),
	}

	dataKey, errs := tree.GenerateDataKeyWithKeyServices(svcs)
	if len(errs) > 0 {
		return nil, err
	}

	cipher := aes.NewCipher()
	unencryptedMac, err := tree.Encrypt(dataKey, cipher)
	if err != nil {
		return nil, err
	}

	tree.Metadata.LastModified = time.Now().UTC()
	tree.Metadata.MessageAuthenticationCode, err = cipher.Encrypt(unencryptedMac, dataKey, tree.Metadata.LastModified.Format(time.RFC3339))
	if err != nil {
		return nil, err
	}

	return common.StoreForFormat(formats.Json).EmitEncryptedFile(tree)
}

func decryptData(data []byte) ([]byte, error) {
	store := common.StoreForFormat(formats.Binary)
	fmt.Println(string(data))

	tree, err := store.LoadEncryptedFile(data)
	if err != nil {
		return nil, err
	}

	svcs := []keyservice.KeyServiceClient{
		keyservice.NewLocalClient(),
	}

	dataKey, errs := tree.GenerateDataKeyWithKeyServices(svcs)
	if len(errs) > 0 {
		return nil, err
	}

	cipher := aes.NewCipher()
	_, err = tree.Decrypt(dataKey, cipher)
	if err != nil {
		return nil, err
	}

	res, err := common.StoreForFormat(formats.Binary).EmitPlainFile(tree.Branches)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func getFieldsToEncode(tree *ast.File) []ast.Node {
	fields := make([]ast.Node, 0)
	ast.Walk(tree, func(n ast.Node) bool {
		switch n.(type) {
		case *ast.Field:
			field := n.(*ast.Field)
			if len(field.Attrs) == 0 {
				return true
			}

			var (
				ident, data string
				encoded     bool = true
			)

			for _, a := range field.Attrs {
				ident, data = a.Split()
				if ident != "secret" {
					continue
				}
				parts := strings.SplitN(data, ",", -1)
				if len(parts) == 0 || parts[0] == "raw" {
					encoded = false
				}
				break
			}

			if ident == "" {
				return true
			}

			if encoded == true {
				return true
			}

			fields = append(fields, n)
		}
		return true
	}, nil)
	return fields
}

func insertEncodedValues(tree *ast.File, v cue.Value, op Operation) (ast.Node, error) {
	f := func(c astutil.Cursor) bool {
		n := c.Node()
		switch n.(type) {
		case *ast.Field:
			field := n.(*ast.Field)
			if len(field.Attrs) == 0 {
				return true
			}

			var (
				ident, data string
				encoded     bool = true
			)

			for _, a := range field.Attrs {
				ident, data = a.Split()
				if ident != "secret" {
					continue
				}
				parts := strings.SplitN(data, ",", -1)
				if len(parts) == 0 || parts[0] == "raw" {
					encoded = false
				}
				break
			}

			if ident == "" ||
				(op == encrypt && encoded == true) ||
				(op == decrypt && encoded == false) {
				return true
			}

			pathItems := make([]string, 0)
			parent := c.Parent()
			for parent != nil {
				switch parent.Node().(type) {
				case *ast.Field:
					l := parent.Node().(*ast.Field).Label.(*ast.Ident).Name
					pathItems = append(pathItems, l)
				}
				parent = parent.Parent()
			}

			pathItems = append(pathItems, field.Label.(*ast.Ident).Name)

			updatedValue := v.LookupPath(cue.ParsePath(strings.Join(pathItems, "."))).Syntax()

			field.Value = updatedValue.(ast.Expr)

			switch op {
			case encrypt:
				field.Attrs[0].Text = strings.Replace(field.Attrs[0].Text, "raw", "enc", 1)
			case decrypt:
				field.Attrs[0].Text = strings.Replace(field.Attrs[0].Text, "enc", "raw", 1)
			default:
				panic("not supported")
			}

			c.Replace(field)
		}
		return true
	}

	return astutil.Apply(tree, f, nil), nil
}
